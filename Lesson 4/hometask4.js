/*  Задание 1:
    Написать функцию pow(x,n), которая возвращает x в степени n,
    иначе говоря, умножает x на себя n раз и возвращает результат.
    Запросить у пользователя x и n, а затем вывести результат pow(x,n).
    В этой задаче функция обязана поддерживать только натуральные значения n, т.е. целые от 1 и выше.*/

function pow(x,n) {
    if (!n || n<1) {
        n = +prompt('Введите целое число больше или равно 1!');
    } else if (n===1){
        return x;
    }
    var q = x;
    for (; n>1; n--){
        q = q*x;
    }
    return q;
}
pow(2,3);

function pow(x,n) {
    if (n === 1) {
       return x;
    }
    return x * pow(x,n-1);
}
pow(2,3);

/*  Задание 2:
    Написать функцию sumTo(n), которая для данного n вычисляет сумму чисел от 1 до n, например:
      sumTo(1) = 1
      sumTo(2) = 2 + 1 = 3
      sumTo(3) = 3 + 2 + 1 = 6
      sumTo(4) = 4 + 3 + 2 + 1 = 10
      sumTo(100) = 100 + 99 + ... + 2 + 1 = 5050

    Сделать три варианта решения:
      - с использованием цикла
      - через рекурсию, sumTo(n) = n + sumTo(n-1) для n > 1
      - с использованием формулы для суммы арифметической прогрессии

    Ответить на вопросы в комментариях:
      Какой вариант решения самый быстрый? Самый медленный? Почему?
      Можно ли при помощи рекурсии посчитать sumTo(100000)? Если нет, то почему?*/

//с использованием цикла
function sumTo(n) {
    var sum=0;
    for (; n >= 1; n--){
        sum = sum+n;
    }
    return sum;
}
sumTo(3);

//через рекурсию
function sumTo(n) {
   if (n<1)  return n;
    return n + sumTo(n-1);
}
sumTo(100000);

//с использованием формулы для суммы арифметической прогрессии
function sumTo(n) {
    var sum = ((1 + n)/2)*n;
    return console.log(sum);
}
sumTo(3);

/*Какой вариант решения самый быстрый? Самый медленный? Почему?
    Самый быстрый вариант решения через формулу, т.к. он использует всего лишь одно вычисление,
        используя простые операторы (сложение, деление и умножение);
    Самый медленный через рекурсию, т.к. он в процессе своего выполнения вызывает функцию n раз,
        пока не достигнется условие выхода из рекурсии,
        а т.к. для каждой функции создается свой LE, Scope и может быть много чего другого,
        то пока это все создатся и обработается, пройдет больше времени
        и кроме того это займет большее количество памяти.

    Можно ли при помощи рекурсии посчитать sumTo(100000)? Если нет, то почему?
    Нет, потому что вряд ли браузера хватит на выполнение такого количества повторений функции.
 */

/*Задание 3 N.05 (другим сболее математичным способом, соблюдая условие чистоты и отсутствия вложенности функций,
 у меня решить не получилось (вернее я не додумалась как это сделать))*/

function treeSum(arr) {
    var arr,
        str,
        sum = 0;
    if (typeof arr == "object" && arr.length >= 0 ) {
        arr = ',' + String(arr) + ',';
        for(var i = 0; i <= arr.length; i++) {
            if (arr[i] === ',' &&  Number( arr[i + 1] ) ){
                str = '';
                for (var j = i + 1; arr[j] === '0' || Number( arr[j] ) ;j++){
                    str += arr[j];
                }
                sum+=Number(str);
            } else if  (arr[i] === ',' && arr[i + 1] === '-' ){
                str = arr[i+1];
                for (var m = i + 2; arr[m] === '0' || Number( arr[m] ) ;m++){
                    str += arr[m];
                }
                sum += Number(str);
            }
        }
    } else {
        alert('Это не массив!');
    }
    return sum;
}
treeSum([ -5, 70, [ 42, [2], -8, [1,3], 2], [ 9, ['sfeegv'] ], 1, 8 ]);

// О БОЖЕ Я НЕ ВЕРЮ, ЧТО У МЕНЯ ПОЛУЧИЛОСЬ!!!!!
function treeSum(arr) {
    var sum = 0;

    for (var i = 0; i < arr.length; i++) {

        if (typeof (arr[i]) === 'object' && arr.length) {
            sum+=treeSum(arr[i]);

        } else if (typeof (arr[i]) === 'number'){
            sum +=arr[i];
        }

    }

    return sum;
}

treeSum([  5, 7, [ 4, [ 2 ], 8, [ 1,3 ], 2 ], [ 9, [] ], 1, 8  ]);