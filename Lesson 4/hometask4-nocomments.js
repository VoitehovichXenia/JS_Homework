//  Задание 1:
 function pow(x,n) {
    if ( !n || n<1 || !Number.isInteger(n) ) {
         n = +prompt('Введите целое число больше 1!');
   }
    var q = x;
    for (; n>1; n--){
        q = q*x;
    }
    return q;
}
pow(2,3);

//через рекурсию
function pow(x,n) {
    if (!n || n<1 || !Number.isInteger(n)) {
        n = +prompt('Введите целое число больше или равно 1!');
    } else if (n===1){

        return x;

    }
    var q = x;
    for (; n>1; n--){
        q = q*x;
    }

    return q;

}
pow(2,3);



//  Задание 2:
 //с использованием цикла
function sumTo(n) {
    var sum=0;
    for (; n >= 1; n--){
        sum = sum+n;
    }
    return sum;
}
sumTo(100);

//через рекурсию
function sumTo(n) {
   if (n<1)  {

       return n;

   }

    return n + sumTo(n-1);
}
sumTo(100);

//с использованием формулы для суммы арифметической прогрессии
function sumTo(n) {
    var sum = ((1 + n)/2)*n;

    return sum;

}
sumTo(100);

/*Какой вариант решения самый быстрый? Самый медленный? Почему?
    Самый быстрый вариант решения через формулу, т.к. он использует всего лишь одно вычисление,
        используя простые операторы (сложение, деление и умножение);
    Самый медленный через рекурсию, т.к. он в процессе своего выполнения вызывает функцию n раз,
        пока не достигнется условие выхода из рекурсии,
        а т.к. для каждой функции создается свой LE, Scope и может быть много чего другого,
        то пока это все создатся и обработается, пройдет больше времени
        и кроме того это займет большее количество памяти.

    Можно ли при помощи рекурсии посчитать sumTo(100000)? Если нет, то почему?
    Нет, потому что вряд ли браузера хватит на выполнение такого количества повторений функции
    (лимит вызовов вложенных ограничен на 10000 вызовов)
 */

/*Задание 3 N.05 */
// О БОЖЕ Я НЕ ВЕРЮ, ЧТО У МЕНЯ ПОЛУЧИЛОСЬ!!!!!
function treeSum(arr) {
    var sum = 0;

    for (var i = 0; i < arr.length; i++) {

        if (typeof (arr[i]) === 'object' && arr.length) {
            sum+=treeSum(arr[i]);

        } else if (typeof (arr[i]) === 'number'){
            sum +=arr[i];
        }

    }

    return sum;
}

treeSum([  5, 7, [ 4, [ 2 ], 8, [ 1,3 ], 2 ], [ 9, [] ], 1, 8  ]);

